<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AS26 Standplan Mapping-Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #1a1a2e; color: #e0e0e0; }

        .toolbar {
            position: fixed; top: 0; left: 0; right: 0; z-index: 100;
            background: #16213e; padding: 10px 20px;
            display: flex; align-items: center; gap: 15px; flex-wrap: wrap;
            border-bottom: 2px solid #e94560;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .toolbar label { font-size: 13px; color: #aaa; }
        .toolbar select, .toolbar input, .toolbar button {
            padding: 6px 12px; border-radius: 4px; border: 1px solid #333;
            background: #0f3460; color: #e0e0e0; font-size: 14px;
        }
        .toolbar button {
            cursor: pointer; font-weight: 600;
            transition: background 0.2s;
        }
        .toolbar button:hover { background: #e94560; }
        .toolbar button.primary { background: #e94560; }
        .toolbar button.primary:hover { background: #c73e54; }
        .toolbar button.danger { background: #a83232; }
        .toolbar button.danger:hover { background: #8a2828; }
        .toolbar .separator { width: 1px; height: 30px; background: #333; margin: 0 5px; }
        .stats { margin-left: auto; font-size: 13px; color: #aaa; }

        .workspace {
            margin-top: 70px; padding: 20px;
            display: flex; gap: 20px; height: calc(100vh - 70px);
        }

        .map-container {
            flex: 1; position: relative; overflow: auto;
            background: #111; border-radius: 8px;
            border: 2px solid #333;
        }
        .image-wrap {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        .image-wrap img {
            display: block; width: 100%; height: auto;
            user-select: none; -webkit-user-drag: none;
        }

        .marker {
            position: absolute; transform: translate(-50%, -50%);
            cursor: pointer; z-index: 10;
        }
        .marker .dot {
            width: 14px; height: 14px; border-radius: 50%;
            background: #e94560; border: 2px solid #fff;
            box-shadow: 0 0 6px rgba(233,69,96,0.8);
        }
        .marker .label {
            position: absolute; left: 50%; top: -24px;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9); color: #fff;
            padding: 2px 6px; border-radius: 3px;
            font-size: 11px; white-space: nowrap;
            pointer-events: none;
        }
        .marker:hover .dot { background: #ff6b81; box-shadow: 0 0 14px rgba(233,69,96,1); }
        .marker.selected .dot { background: #ffd93d; border-color: #ffd93d; box-shadow: 0 0 12px rgba(255,217,61,0.8); }
        .marker.rect-mode { transform: none; border: 2px solid #e94560; background: rgba(233,69,96,0.2); border-radius: 2px; }
        .marker.rect-mode .dot { display: none; }
        .marker.rect-mode .label { top: -20px; left: 0; transform: none; }

        .crosshair { position: absolute; pointer-events: none; z-index: 5; display: none; }
        .crosshair .h-line, .crosshair .v-line { position: absolute; background: rgba(233,69,96,0.4); }
        .crosshair .h-line { left: 0; right: 0; height: 1px; }
        .crosshair .v-line { top: 0; bottom: 0; width: 1px; }

        .rect-preview { position: absolute; border: 2px dashed #ffd93d; background: rgba(255,217,61,0.15); pointer-events: none; z-index: 15; }

        .coords-display {
            position: fixed; bottom: 20px; left: 20px; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 8px 14px;
            border-radius: 6px; font-family: monospace; font-size: 14px;
        }

        /* ===== SIDEBAR ===== */
        .sidebar {
            width: 380px; display: flex; flex-direction: column; gap: 0;
            background: #16213e; border-radius: 8px;
            border: 1px solid #333; overflow: hidden;
        }

        .sidebar-section {
            padding: 12px 15px; border-bottom: 1px solid #333;
        }
        .sidebar-section:last-child { border-bottom: none; }
        .sidebar-section h3 { font-size: 14px; color: #e94560; margin-bottom: 8px; }

        /* Pending stands - the pick list */
        .pending-section { flex: 1; overflow-y: auto; min-height: 0; }
        .pending-list { list-style: none; display: flex; flex-wrap: wrap; gap: 4px; }
        .pending-list li {
            padding: 4px 10px; background: #0f3460; border-radius: 4px;
            font-size: 13px; cursor: pointer; transition: all 0.15s;
            border: 2px solid transparent;
        }
        .pending-list li:hover { background: #1a4a7a; }
        .pending-list li.active {
            background: #ffd93d; color: #000; font-weight: 700;
            border-color: #fff; animation: pulse-pick 1s infinite;
        }
        @keyframes pulse-pick {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255,217,61,0.6); }
            50% { box-shadow: 0 0 0 4px rgba(255,217,61,0); }
        }

        /* Placed stands list */
        .placed-section { max-height: 250px; overflow-y: auto; }
        .placed-list { list-style: none; }
        .placed-list li {
            padding: 6px 10px; margin-bottom: 3px; background: #0a2a4a;
            border-radius: 4px; display: flex; justify-content: space-between;
            align-items: center; font-size: 13px; cursor: pointer;
            transition: background 0.15s;
        }
        .placed-list li:hover { background: #1a4a7a; }
        .placed-list li.selected { background: #e94560; }
        .placed-list li .coords { font-family: monospace; font-size: 11px; color: #aaa; }
        .placed-list li.selected .coords { color: #ffd93d; }
        .placed-list li .btn-delete {
            background: none; border: none; color: #e94560;
            cursor: pointer; font-size: 16px; padding: 0 4px;
        }
        .placed-list li.selected .btn-delete { color: #fff; }

        .progress-bar {
            height: 4px; background: #333; border-radius: 2px; margin-top: 6px; overflow: hidden;
        }
        .progress-bar .fill { height: 100%; background: #4caf50; transition: width 0.3s; border-radius: 2px; }

        /* Import area */
        .import-area textarea {
            width: 100%; height: 60px; background: #0a0a1a; color: #e0e0e0;
            border: 1px solid #333; border-radius: 4px; padding: 8px;
            font-family: monospace; font-size: 12px; resize: vertical;
        }

        .help {
            position: fixed; bottom: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.85); padding: 10px 14px;
            border-radius: 6px; font-size: 12px; color: #aaa;
            max-width: 320px; line-height: 1.6;
        }
        .help kbd { background: #333; padding: 1px 5px; border-radius: 3px; font-size: 11px; }

        .drop-zone {
            display: flex; align-items: center; justify-content: center;
            height: 400px; border: 3px dashed #333;
            border-radius: 8px; color: #555; font-size: 18px;
            text-align: center; padding: 40px;
        }
        .drop-zone.dragover { border-color: #e94560; color: #e94560; }

        .mode-indicator { padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600; }
        .mode-indicator.point { background: #e94560; }
        .mode-indicator.rect { background: #ffd93d; color: #000; }

        .load-status { font-size: 12px; padding: 4px 8px; border-radius: 4px; }
        .load-status.ok { color: #4caf50; }
        .load-status.warn { color: #ffd93d; }
        .load-status.err { color: #e94560; }

        .manual-input { display: flex; gap: 4px; margin-top: 8px; }
        .manual-input input {
            flex: 1; padding: 4px 8px; background: #0a0a1a; color: #e0e0e0;
            border: 1px solid #333; border-radius: 4px; font-size: 13px;
        }
        .manual-input button {
            padding: 4px 10px; background: #0f3460; color: #e0e0e0;
            border: 1px solid #333; border-radius: 4px; cursor: pointer;
            font-size: 13px;
        }
    </style>
</head>
<body>

<div class="toolbar">
    <label>Halle:</label>
    <select id="halleSelect">
        <option value="">-- Halle waehlen --</option>
        <option value="FW">FW - Foyer West</option>
        <option value="FG">FG - Freigelaende West</option>
        <option value="A3">A3 - Halle A3</option>
        <option value="A4">A4 - Halle A4</option>
        <option value="A5">A5 - Halle A5</option>
        <option value="A6">A6 - Halle A6</option>
    </select>

    <div class="separator"></div>

    <label>Modus:</label>
    <span class="mode-indicator point" id="modeIndicator">Punkt</span>
    <button onclick="toggleMode()">Wechseln (<kbd>M</kbd>)</button>

    <div class="separator"></div>

    <button class="primary" onclick="saveToNotion()">&#x1f4be; Save to Notion</button>
    <div class="separator"></div>
    <button onclick="exportJSON()">Export JSON</button>
    <button onclick="copyJSON()">Copy JSON</button>
    <button class="danger" onclick="clearAll()">Halle leeren</button>

    <span class="load-status" id="loadStatus"></span>
    <div class="stats" id="stats">0 / 0 Staende</div>
</div>

<div class="workspace">
    <div class="map-container" id="mapContainer">
        <div class="drop-zone" id="dropZone">
            Oben eine Halle auswaehlen, um den Plan zu laden
        </div>
        <div class="image-wrap" id="imageWrap" style="display:none">
            <img id="mapImage" alt="Hallenplan">
            <div class="rect-preview" id="rectPreview" style="display:none"></div>
        </div>
        <div class="crosshair" id="crosshair">
            <div class="h-line"></div>
            <div class="v-line"></div>
        </div>
    </div>

    <div class="sidebar">
        <!-- Pending stands (pick list) -->
        <div class="sidebar-section pending-section" id="pendingSection">
            <h3 id="pendingTitle">Noch zu platzieren (0)</h3>
            <ul class="pending-list" id="pendingList"></ul>
            <div class="manual-input">
                <input type="text" id="manualStandInput" placeholder="Manuell: z.B. 301">
                <button onclick="manualAddPending()">+</button>
            </div>
            <div class="progress-bar"><div class="fill" id="progressFill" style="width:0%"></div></div>
        </div>

        <!-- Placed stands -->
        <div class="sidebar-section placed-section">
            <h3 id="placedTitle">Platziert (0)</h3>
            <ul class="placed-list" id="placedList"></ul>
        </div>

        <!-- Import -->
        <div class="sidebar-section">
            <label style="font-size:13px;color:#aaa">Import (standplan.json):</label>
            <textarea id="importArea" placeholder='{"hallen":{...},"staende":{...}}'></textarea>
            <button onclick="importJSON()" style="margin-top:5px;width:100%">Importieren</button>
        </div>
    </div>
</div>

<div class="coords-display" id="coordsDisplay">X: --.-- % | Y: --.-- %</div>

<div class="help">
    <strong>Workflow:</strong><br>
    1. Halle waehlen (oben)<br>
    2. Stand in der Liste anklicken (gelb)<br>
    3. Position auf dem Plan klicken<br>
    4. Fertig! Naechsten Stand waehlen<br><br>
    <kbd>M</kbd> Punkt/Rechteck-Modus<br>
    <kbd>Del</kbd> Ausgewaehlten loeschen<br>
    <kbd>Esc</kbd> Auswahl aufheben<br>
    Rechteck: Klick+Drag
</div>

<script>
// ===== HALL CONFIG =====
const HALL_CONFIG = {
    FW:  { bild: '/img/plan/FW.jpg',  label: 'Foyer West',        prefixes: ['FW', 'AT'] },
    FG:  { bild: '/img/plan/FG.jpg',  label: 'Freigelaende West', prefixes: ['FG', 'FGO'] },
    A3:  { bild: '/img/plan/A3.jpg',  label: 'Halle A3',          prefixes: ['A3'] },
    A4:  { bild: '/img/plan/A4.jpg',  label: 'Halle A4',          prefixes: ['A4'] },
    A5:  { bild: '/img/plan/A5.jpg',  label: 'Halle A5',          prefixes: ['A5'] },
    A6:  { bild: '/img/plan/A6.jpg',  label: 'Halle A6',          prefixes: ['A6'] },
};

// Export paths (for the generated JSON, different from local dev paths)
const EXPORT_PATHS = {
    FW:  '/img/plan/FW.jpg',
    AT:  '/img/plan/FW.jpg',
    FG:  '/img/plan/FG.jpg',
    FGO: '/img/plan/FG.jpg',
    A3:  '/img/plan/A3.jpg',
    A4:  '/img/plan/A4.jpg',
    A5:  '/img/plan/A5.jpg',
    A6:  '/img/plan/A6.jpg',
};

const EXPORT_LABELS = {
    FW:  'Foyer West',
    AT:  'Foyer West (Atrium)',
    FG:  'Freigelaende West',
    FGO: 'Freigelaende Ost',
    A3:  'Halle A3',
    A4:  'Halle A4',
    A5:  'Halle A5',
    A6:  'Halle A6',
};

// ===== STATE =====
const state = {
    staende: {},           // placed: { "A3-300": { x, y, w?, h? } }
    allStandNummern: [],   // all stand numbers from aussteller.json
    standToPageId: {},     // mapping: stand number -> Notion page UUID
    currentHalle: '',
    selectedStand: null,   // selected in placed list (for deletion)
    pendingPick: null,     // stand number selected for placement
    mode: 'point',
    rectStart: null,
};

// ===== DOM =====
const mapContainer = document.getElementById('mapContainer');
const imageWrap = document.getElementById('imageWrap');
const mapImage = document.getElementById('mapImage');
const dropZone = document.getElementById('dropZone');
const crosshair = document.getElementById('crosshair');
const rectPreview = document.getElementById('rectPreview');
const coordsDisplay = document.getElementById('coordsDisplay');
const halleSelect = document.getElementById('halleSelect');
const modeIndicator = document.getElementById('modeIndicator');
const statsEl = document.getElementById('stats');
const pendingList = document.getElementById('pendingList');
const placedList = document.getElementById('placedList');
const pendingTitle = document.getElementById('pendingTitle');
const placedTitle = document.getElementById('placedTitle');
const progressFill = document.getElementById('progressFill');
const loadStatus = document.getElementById('loadStatus');

// ===== LOAD AUSSTELLER DATA =====
async function loadAusstellerData() {
    loadStatus.textContent = 'Lade Aussteller...';
    loadStatus.className = 'load-status warn';

    try {
        const res = await fetch('/api/aussteller.json');
        const data = await res.json();

        if (data.aussteller && data.aussteller.length > 0) {
            state.allStandNummern = [];
            for (const a of data.aussteller) {
                if (!a.stand || !a.stand.includes('-')) continue;
                state.allStandNummern.push(a.stand);

                // page_id Mapping speichern
                if (a.page_id) {
                    state.standToPageId[a.stand] = a.page_id;
                }

                // Bestehende Koordinaten aus Notion laden
                if (a.stand_x != null && a.stand_y != null) {
                    const entry = { x: a.stand_x, y: a.stand_y };
                    if (a.stand_w != null) entry.w = a.stand_w;
                    if (a.stand_h != null) entry.h = a.stand_h;
                    state.staende[a.stand] = entry;
                }
            }
            state.allStandNummern.sort();

            const coordCount = Object.keys(state.staende).length;
            loadStatus.textContent = `${state.allStandNummern.length} Staende, ${coordCount} mit Koordinaten`;
            loadStatus.className = 'load-status ok';
        } else {
            loadStatus.textContent = 'aussteller.json leer - manuell eingeben';
            loadStatus.className = 'load-status warn';
        }
    } catch (e) {
        loadStatus.textContent = 'aussteller.json nicht gefunden - manuell eingeben';
        loadStatus.className = 'load-status warn';
    }

    updateStats();
    renderPending();
}

// ===== HALL SWITCH =====
halleSelect.addEventListener('change', (e) => switchHalle(e.target.value));

function switchHalle(prefix) {
    state.currentHalle = prefix;
    state.selectedStand = null;
    state.pendingPick = null;

    const config = HALL_CONFIG[prefix];
    if (config) {
        mapImage.src = config.bild;
        imageWrap.style.display = 'inline-block';
        dropZone.style.display = 'none';
    } else {
        imageWrap.style.display = 'none';
        dropZone.style.display = 'flex';
    }

    renderMarkers();
    renderPending();
    renderPlaced();
    updateStats();
}

// ===== GET STANDS FOR CURRENT HALL =====
function getPrefixesForHall(hall) {
    const config = HALL_CONFIG[hall];
    return config ? config.prefixes : [hall];
}

function standBelongsToHall(standNr, hall) {
    const prefixes = getPrefixesForHall(hall);
    return prefixes.some(p => standNr.startsWith(p + '-'));
}

function getHallStands() {
    if (!state.currentHalle) return { pending: [], placed: [] };
    const all = state.allStandNummern.filter(s => standBelongsToHall(s, state.currentHalle));
    const placed = all.filter(s => state.staende[s]);
    const pending = all.filter(s => !state.staende[s]);
    // Also include manually placed stands not in aussteller.json
    const extraPlaced = Object.keys(state.staende)
        .filter(s => standBelongsToHall(s, state.currentHalle) && !all.includes(s));
    return { pending, placed: [...placed, ...extraPlaced].sort() };
}

// ===== RENDER PENDING LIST =====
function renderPending() {
    const { pending } = getHallStands();
    pendingTitle.textContent = `Noch zu platzieren (${pending.length})`;
    pendingList.innerHTML = '';

    for (const nr of pending) {
        const li = document.createElement('li');
        li.textContent = nr;
        if (state.pendingPick === nr) li.classList.add('active');
        li.addEventListener('click', () => {
            state.pendingPick = (state.pendingPick === nr) ? null : nr;
            state.selectedStand = null;
            renderPending();
            renderPlaced();
            renderMarkers();
        });
        pendingList.appendChild(li);
    }

    updateProgress();
}

// ===== RENDER PLACED LIST =====
function renderPlaced() {
    const { placed } = getHallStands();
    placedTitle.textContent = `Platziert (${placed.length})`;
    placedList.innerHTML = '';

    for (const key of placed) {
        const data = state.staende[key];
        if (!data) continue;

        const li = document.createElement('li');
        li.className = key === state.selectedStand ? 'selected' : '';

        const nameSpan = document.createElement('span');
        nameSpan.textContent = key;

        const coordsSpan = document.createElement('span');
        coordsSpan.className = 'coords';
        coordsSpan.textContent = data.w
            ? `${data.x}/${data.y} (${data.w}x${data.h})`
            : `${data.x}/${data.y}`;

        const delBtn = document.createElement('button');
        delBtn.className = 'btn-delete';
        delBtn.textContent = '\u00d7';
        delBtn.title = 'Loeschen';
        delBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            delete state.staende[key];
            if (state.selectedStand === key) state.selectedStand = null;
            saveDraft();
            renderMarkers();
            renderPending();
            renderPlaced();
            updateStats();
        });

        li.appendChild(nameSpan);
        li.appendChild(coordsSpan);
        li.appendChild(delBtn);

        li.addEventListener('click', () => {
            state.selectedStand = key;
            state.pendingPick = null;
            renderPending();
            renderPlaced();
            renderMarkers();
        });

        placedList.appendChild(li);
    }
}

// ===== PROGRESS BAR =====
function updateProgress() {
    const { pending, placed } = getHallStands();
    const total = pending.length + placed.length;
    const pct = total > 0 ? (placed.length / total) * 100 : 0;
    progressFill.style.width = pct + '%';
}

// ===== STATS =====
function updateStats() {
    const totalPlaced = Object.keys(state.staende).length;
    const totalKnown = state.allStandNummern.length;
    statsEl.textContent = `${totalPlaced} / ${totalKnown || '?'} Staende`;
}

// ===== COORDINATE CALC =====
function getPercent(e) {
    const rect = mapImage.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 100;
    const y = ((e.clientY - rect.top) / rect.height) * 100;
    return { x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10 };
}

// ===== MOUSE EVENTS =====
mapContainer.addEventListener('mousemove', (e) => {
    if (!mapImage.src || mapImage.style.display === 'none') return;
    const pos = getPercent(e);
    coordsDisplay.textContent = `X: ${pos.x.toFixed(1)} % | Y: ${pos.y.toFixed(1)} %`;

    const containerRect = mapContainer.getBoundingClientRect();
    crosshair.style.display = 'block';
    crosshair.querySelector('.h-line').style.top = (e.clientY - containerRect.top + mapContainer.scrollTop) + 'px';
    crosshair.querySelector('.v-line').style.left = (e.clientX - containerRect.left + mapContainer.scrollLeft) + 'px';

    if (state.mode === 'rect' && state.rectStart) {
        const sx = state.rectStart.x, sy = state.rectStart.y;
        rectPreview.style.display = 'block';
        rectPreview.style.left = Math.min(sx, pos.x) + '%';
        rectPreview.style.top = Math.min(sy, pos.y) + '%';
        rectPreview.style.width = Math.abs(pos.x - sx) + '%';
        rectPreview.style.height = Math.abs(pos.y - sy) + '%';
    }
});

mapContainer.addEventListener('mouseleave', () => { crosshair.style.display = 'none'; });

mapContainer.addEventListener('mousedown', (e) => {
    if (e.target.closest('.marker')) return;
    if (!mapImage.src || mapImage.style.display === 'none') return;
    if (!state.currentHalle) return;

    if (state.mode === 'rect') {
        state.rectStart = getPercent(e);
        e.preventDefault();
    }
});

mapContainer.addEventListener('mouseup', (e) => {
    if (e.target.closest('.marker')) return;
    if (!mapImage.src || mapImage.style.display === 'none') return;
    if (!state.currentHalle) return;

    const pos = getPercent(e);

    if (state.mode === 'point') {
        placeStand(pos);
    } else if (state.mode === 'rect' && state.rectStart) {
        const sx = state.rectStart.x, sy = state.rectStart.y;
        const w = Math.abs(pos.x - sx), h = Math.abs(pos.y - sy);

        if (w < 0.5 && h < 0.5) {
            placeStand(pos);
        } else {
            const cx = Math.round(((Math.min(sx, pos.x) + w / 2) * 10)) / 10;
            const cy = Math.round(((Math.min(sy, pos.y) + h / 2) * 10)) / 10;
            placeStand({ x: cx, y: cy, w: Math.round(w * 10) / 10, h: Math.round(h * 10) / 10 });
        }
        state.rectStart = null;
        rectPreview.style.display = 'none';
    }
});

// ===== PLACE STAND =====
function placeStand(pos) {
    let key = state.pendingPick;

    if (!key) {
        // Kein Stand ausgewaehlt - Klick ignorieren statt prompt()
        return;
    }

    const entry = { x: pos.x, y: pos.y };
    if (pos.w) { entry.w = pos.w; entry.h = pos.h; }
    state.staende[key] = entry;
    saveDraft();

    // Auto-advance to next pending stand
    const { pending } = getHallStands();
    state.pendingPick = pending.length > 0 ? pending[0] : null;
    state.selectedStand = null;

    renderMarkers();
    renderPending();
    renderPlaced();
    updateStats();
}

// ===== MANUAL ADD =====
function manualAddPending() {
    const input = document.getElementById('manualStandInput');
    let val = input.value.trim();
    if (!val) return;

    if (!val.includes('-') && state.currentHalle) {
        val = state.currentHalle + '-' + val;
    }

    if (!state.allStandNummern.includes(val)) {
        state.allStandNummern.push(val);
        state.allStandNummern.sort();
    }

    input.value = '';
    renderPending();
    updateStats();
}

// ===== RENDER MARKERS =====
function renderMarkers() {
    imageWrap.querySelectorAll('.marker').forEach(m => m.remove());
    if (!state.currentHalle) return;

    for (const [key, data] of Object.entries(state.staende)) {
        if (!standBelongsToHall(key, state.currentHalle)) continue;

        const marker = document.createElement('div');
        marker.className = 'marker' + (key === state.selectedStand ? ' selected' : '');

        if (data.w && data.h) {
            marker.classList.add('rect-mode');
            marker.style.left = (data.x - data.w / 2) + '%';
            marker.style.top = (data.y - data.h / 2) + '%';
            marker.style.width = data.w + '%';
            marker.style.height = data.h + '%';
        } else {
            marker.style.left = data.x + '%';
            marker.style.top = data.y + '%';
        }

        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = key;
        marker.appendChild(label);

        if (!(data.w && data.h)) {
            const dot = document.createElement('span');
            dot.className = 'dot';
            marker.appendChild(dot);
        }

        marker.addEventListener('click', (e) => {
            e.stopPropagation();
            state.selectedStand = key;
            state.pendingPick = null;
            renderMarkers();
            renderPending();
            renderPlaced();
        });

        imageWrap.appendChild(marker);
    }
}

// ===== MODE TOGGLE =====
function toggleMode() {
    state.mode = state.mode === 'point' ? 'rect' : 'point';
    modeIndicator.textContent = state.mode === 'point' ? 'Punkt' : 'Rechteck';
    modeIndicator.className = 'mode-indicator ' + state.mode;
    state.rectStart = null;
    rectPreview.style.display = 'none';
}

// ===== KEYBOARD =====
document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    if (e.key === 'm' || e.key === 'M') {
        toggleMode();
    } else if (e.key === 'Delete' || e.key === 'Backspace') {
        if (state.selectedStand) {
            delete state.staende[state.selectedStand];
            state.selectedStand = null;
            saveDraft();
            renderMarkers();
            renderPending();
            renderPlaced();
            updateStats();
        }
    } else if (e.key === 'Escape') {
        state.selectedStand = null;
        state.pendingPick = null;
        state.rectStart = null;
        rectPreview.style.display = 'none';
        renderMarkers();
        renderPending();
        renderPlaced();
    }
});

// ===== EXPORT / IMPORT =====
function buildExportJSON() {
    // Build hallen from all known prefixes that have stands
    const usedPrefixes = new Set();
    for (const key of Object.keys(state.staende)) {
        const prefix = key.split('-')[0];
        usedPrefixes.add(prefix);
    }
    // Always include all configured halls
    for (const hall of Object.values(HALL_CONFIG)) {
        for (const p of hall.prefixes) usedPrefixes.add(p);
    }

    const hallen = {};
    for (const prefix of [...usedPrefixes].sort()) {
        if (EXPORT_PATHS[prefix]) {
            hallen[prefix] = { bild: EXPORT_PATHS[prefix], label: EXPORT_LABELS[prefix] || prefix };
        }
    }

    const staende = {};
    for (const [key, data] of Object.entries(state.staende)) {
        const entry = { x: data.x, y: data.y };
        if (data.w) entry.w = data.w;
        if (data.h) entry.h = data.h;
        staende[key] = entry;
    }

    return { generated: new Date().toISOString(), hallen, staende };
}

function exportJSON() {
    const json = JSON.stringify(buildExportJSON(), null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'standplan.json';
    a.click();
    URL.revokeObjectURL(url);
}

function copyJSON() {
    const json = JSON.stringify(buildExportJSON(), null, 2);
    navigator.clipboard.writeText(json).then(() => alert('JSON in Zwischenablage kopiert!'));
}

function importJSON() {
    const text = document.getElementById('importArea').value.trim();
    if (!text) return;
    try {
        const data = JSON.parse(text);
        if (data.staende) {
            Object.assign(state.staende, data.staende);
        }
        renderMarkers();
        renderPending();
        renderPlaced();
        updateStats();
        alert(`Import: ${Object.keys(data.staende || {}).length} Staende geladen`);
    } catch (e) {
        alert('Fehler beim Import: ' + e.message);
    }
}

function clearAll() {
    if (!state.currentHalle) return;
    const prefixes = getPrefixesForHall(state.currentHalle);
    const label = HALL_CONFIG[state.currentHalle]?.label || state.currentHalle;
    if (!confirm(`Alle Staende von ${label} loeschen?`)) return;

    for (const key of Object.keys(state.staende)) {
        if (prefixes.some(p => key.startsWith(p + '-'))) {
            delete state.staende[key];
        }
    }
    state.selectedStand = null;
    state.pendingPick = null;
    saveDraft();
    renderMarkers();
    renderPending();
    renderPlaced();
    updateStats();
}

// ===== SAVE TO NOTION =====
async function saveToNotion() {
    const placed = Object.entries(state.staende);
    if (placed.length === 0) {
        alert('Keine platzierten Staende zum Speichern.');
        return;
    }

    // Nur Staende mit page_id koennen gespeichert werden
    const items = [];
    const skipped = [];
    for (const [stand, data] of placed) {
        const pageId = state.standToPageId[stand];
        if (!pageId) {
            skipped.push(stand);
            continue;
        }
        items.push({
            page_id: pageId,
            stand: stand,
            x: data.x,
            y: data.y,
            w: data.w || null,
            h: data.h || null,
        });
    }

    if (items.length === 0) {
        alert('Keine Staende mit Notion page_id gefunden.');
        return;
    }

    const skipMsg = skipped.length > 0 ? `\n${skipped.length} Staende ohne page_id werden uebersprungen.` : '';
    if (!confirm(`${items.length} Staende in Notion speichern?${skipMsg}\n\nDas dauert ca. ${Math.ceil(items.length * 0.4)} Sekunden.`)) return;

    // UI feedback
    loadStatus.textContent = `Speichere 0/${items.length}...`;
    loadStatus.className = 'load-status warn';

    try {
        // Sende in Batches von 20 um Timeout zu vermeiden
        const BATCH_SIZE = 20;
        let totalUpdated = 0;
        let totalFailed = 0;
        const allErrors = [];

        for (let i = 0; i < items.length; i += BATCH_SIZE) {
            const batch = items.slice(i, i + BATCH_SIZE);
            loadStatus.textContent = `Speichere ${i}/${items.length}...`;

            const resp = await fetch('/api/standplan-save.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ items: batch }),
            });

            const result = await resp.json();
            totalUpdated += result.updated || 0;
            totalFailed += result.failed || 0;
            if (result.errors) allErrors.push(...result.errors);
        }

        loadStatus.textContent = `Gespeichert: ${totalUpdated} OK, ${totalFailed} Fehler`;
        loadStatus.className = totalFailed > 0 ? 'load-status warn' : 'load-status ok';

        let msg = `${totalUpdated} Staende in Notion gespeichert.`;
        if (totalFailed > 0) msg += `\n${totalFailed} Fehler: ${allErrors.join(', ')}`;
        if (skipped.length > 0) msg += `\n${skipped.length} ohne page_id uebersprungen.`;
        alert(msg);

        // localStorage leeren nach erfolgreichem Save
        if (totalFailed === 0) {
            localStorage.removeItem('standplan-draft');
        }
    } catch (e) {
        loadStatus.textContent = 'Fehler beim Speichern!';
        loadStatus.className = 'load-status err';
        alert('Fehler beim Speichern: ' + e.message);
    }
}

// ===== LOCALSTORAGE PERSISTENCE =====
function saveDraft() {
    try {
        localStorage.setItem('standplan-draft', JSON.stringify(state.staende));
    } catch (e) { /* ignore quota errors */ }
}

function loadDraft() {
    try {
        const draft = localStorage.getItem('standplan-draft');
        if (draft) {
            Object.assign(state.staende, JSON.parse(draft));
        }
    } catch (e) { /* ignore parse errors */ }
}

async function loadExistingStandplan() {
    // Koordinaten werden jetzt direkt aus aussteller.json geladen (in loadAusstellerData)
    // localStorage-Draft ueberschreibt bei Bedarf
    loadDraft();
}

// ===== INIT =====
async function init() {
    await loadAusstellerData();
    await loadExistingStandplan();
    renderMarkers();
    renderPending();
    renderPlaced();
    updateStats();
}
init();
</script>

</body>
</html>
